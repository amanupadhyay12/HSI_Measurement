/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>

#define RCC_BASE_ADDR						0x40023800UL

#define RCC_CFGR_REG_OFFSET			        0x08UL

#define RCC_CR_REG_OFFSET					0x00UL

#define RCC_CFGR_REG_ADDR					( RCC_BASE_ADDR + RCC_CFGR_REG_OFFSET )

#define RCC_CR_REG_ADDR						( RCC_BASE_ADDR + RCC_CR_REG_OFFSET )

#define GPIOA_BASE_ADDR						0x40020000UL

int main(void)
{
	uint32_t *pRccCrReg		= (uint32_t *)(RCC_CR_REG_ADDR);
	uint32_t *pRccCFGRReg	= (uint32_t *)(RCC_CFGR_REG_ADDR);
	//1. Enable the HSE Clock using HSEON bit (RCC_CR)
	*pRccCrReg  |= (1 << 16 );
	//2. wait until HSE clock from the external crystal stabilizes (only if crystal is connected)
	while( !(*pRccCrReg & (1 << 17 ) ) );
	//3. Switch the system clock to HSE (RCC_CFGR)
	*pRccCFGRReg |= (1 << 0);


	//4. Do MCO1 settings to measure it.

	/* 1. Configure the RCC_CFGR register MCO1 bit fields to select HSI as clock source */
		*pRccCFGRReg |= ( 1 << 22 ); /* 2. Clear the 21 and set 22 bit positions */

		//Configure MCO1 prescaler //divisor as 4
		*pRccCFGRReg |= (1 << 25 );
		*pRccCFGRReg |= (1 << 26 );
		/* 2. Configure PA8 to AF0 mode to have as MCO1 signal */
		/*
		 * You are not expected to understand the below codes for time being
		 * because these code are related to GPIO configurations
		 */

		/* a) Enable the peripheral clock for GPIOA peripheral */
		uint32_t *pRCCAhb1Enr	=	(uint32_t *)(RCC_BASE_ADDR + 0x30);
		*pRCCAhb1Enr	|= ( 1 << 0);

		/* b) Configure the mode of GPIOA pin 8 as alternate function */
		uint32_t *pGPIOAModeReg	=	(uint32_t *)(GPIOA_BASE_ADDR + 0x00);
		*pGPIOAModeReg &= ~( 0x03 << 16);
		*pGPIOAModeReg |= ( 0x2 << 16);


		/* c) Configure the alternation function register to set the mode for PA8 */

		uint32_t *pGPIOAAltFnHighReg	= (uint32_t *) (GPIOA_BASE_ADDR + 0x24);
		*pGPIOAAltFnHighReg	&= ~( 0xF << 0);

    /* Loop forever */
	for(;;);
}
